<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<meta name="description" 
 content="A test wrap for SCORM 1.2 SCOs. Copyright 2001-2003 by Click2learn, Inc. Updated and maintained by Brian Caudill https://www.elearningllc.com/scormwraptest/docs brian.m.caudill@gmail.com" />
<meta name="generator" content="Claude Ostyn (by hand)" />
<title>SCO Test Wrap for SCORM 1.2</title>

<script type="text/javascript" language="JavaScript">
// Concocted by Claude Ostyn 2003-04-15
// Copyright 2001-2003 Click2learn, Inc. All rights reserved
// No part of this script or associated files and documents may be
// reproduced or sold without written approval from the
// copyright owner.
// This script if the private API housekeeping script for the wrapper SCO 
// Updated and maintained by Brian Caudill 
// https://www.elearningllc.com/scormwraptest/docs brian.m.caudill@gmail.com
let STR_VERSION = "200305021632";

let B_SHOW_API_ERRORS = false;
let STR_API_NOT_FOUND = "SCORM Test wrapper initialization:\n\nBack end Management system interface not found.";
let STR_API_FOUND = "SCORM Test wrapper initialization:\n\nBack end Management system interface has been found.";
let STR_API_TOO_DEEP = "SCORM Test wrapper initialization:\n\nCannot find back end API - too deeply nested.";
let STR_API_INIT_FAILED = "SCORM Test wrapper initialization:\n\nFound back end API but LMSInitialize failed.";
let STR_THIS_APP_TITLE_IN_CAPS = "SCORM TEST WRAPPER";

let STR_EXPLAIN_CANNOT_RESET_DATA = "Cannot reset the data that persist between launches of the SCO because this information is managed by the back end API in the runtime service that launched this wrapper.\n\nIf the wrapper was running in standalone mode, without a back end, it would maintain a small store of such data.";

let STR_CONFIRM_COULD_RESET_DATA = "OK.\n\nBecause it is running without a back-end API implementation, the test wrapper maintains a small store of data that would persist in an API implementation between launches of the SCO. This information has now been cleared.\n\nNote that in any case this information will not persist between launches of the wrapper, only if you launch the same SCO inside the wrapper without unloading the wrapper.";

let STR_CONFIRM_LOAD_URL = "The test wrapper will attempt to load the SCO\n\n%1\n\nusing the full URL\n\n%2\n\nin %3.";
let STR_IN_STAGE_FRAME = "the stage frame";
let STR_IN_POPUP_WINDOW = "a popup window";

function GetVersion() {
	return STR_VERSION
}

// This string contains placeholders
// %1 = line break  %2 = non break space %3= copyright symbol
let STR_ABOUT_ME = "Click2learn, Inc.%1API%2Test%2Wrapper for SCORM%21.2%1";
STR_ABOUT_ME += "Build " + STR_VERSION ;
STR_ABOUT_ME += "%1Copyright %3%22001-2003 Click2learn,%2Inc.";
STR_ABOUT_ME += " All%2rights%2reserved.";

</script>
<script language="javascript">

function StrAboutThisAsHTML() {
	return ExpandString(STR_ABOUT_ME,"<br />","&nbsp;","&copy;")
}

function StrAboutThisAsText() {
	return ExpandString(STR_ABOUT_ME,"\n"," ","�")
}

function AboutMe() {
	let s = StrAboutThisAsText();
	s += '\n\n';
	s += 'Click OK to view the release notes and terms of use in a separate window.';
	s += '\n\n';
	s += 'If you have not reviewed the terms of use yet, please click OK now.';
	if (confirm(s)){
		window.open("./SCO12TestWrapReadMe.htm")
	}
}

function ExpandString(s){
	let re = new RegExp("%","g")
	for (i = arguments.length-1; i > 0; i--){
		s2 = "%" + i;
		if (s.indexOf(s2) > -1){
			re.compile(s2,"g")
			s = s.replace(re, arguments[i]);
		}
	}
	return s
}


/////////// API INTERFACE INITIALIZATION AND CATCHER FUNCTIONS ////////

// Overall behavior controls
let zbConfirmLoadedURL = true;
let zbRerunOK = false;
let zbWrapperInitsCommunicationWithBackend = false;

let znFindAPITries = 0;
let zobjAPI = null;
let zbInitDone = false;
let zbFinishDone = false;


function AlertUserOfAPIError(strText) {
	if (B_SHOW_API_ERRORS) {
		alert(strText);
	}
}

function ExpandString(s, ...args){
	return s.replace(/%\d+/g, match => args[match.substring(1)-1]);
}

function AboutMe() {
	const s = `${StrAboutThisAsText()}\n\nClick OK to view the release notes and terms of use in a separate window.\n\nIf you have not reviewed the terms of use yet, please click OK now.`;
	if (confirm(s)){
		window.open("./SCO12TestWrapReadMe.htm");
	}
}

function StrAboutThisAsHTML() {
	return ExpandString(STR_ABOUT_ME,"%s","&nbsp;","&copy;");
}

function StrAboutThisAsText() {
	return ExpandString(STR_ABOUT_ME,"\n"," ","�");
}

/////////// API INTERFACE INITIALIZATION AND CATCHER FUNCTIONS ////////

// Overall behavior controls
zbConfirmLoadedURL = true;
zbRerunOK = false;
zbWrapperInitsCommunicationWithBackend = false;

znFindAPITries = 0;
zobjAPI = null;
zbInitDone = false;
zbFinishDone = false;

function FindAPI(win) {
	while ((win.API === null) && (win.parent !== null) && (win.parent !== win)) {
		znFindAPITries ++;
		if (znFindAPITries > 500) {
			if (B_SHOW_API_ERRORS) {
				AlertUserOfAPIError(STR_API_TOO_DEEP);
			}
			return null;
		} 
		win = win.parent;
	}
	return win.API;
}

function APIOK() {
	return (typeof zobjAPI !== "undefined" && zobjAPI !== null);
}

function LMSInitialize(parm) {
	let err = true;
	if (!zbInitDone) {
		if ((window.parent !== null) && (window.parent !== window)) {
			zobjAPI = FindAPI(window.parent);
		}
		if ((zobjAPI === null) && (window.opener !== null)){
			zobjAPI = FindAPI(window.opener);
			// alert("opener tested")
		}
		if (!APIOK()) {
			if (B_SHOW_API_ERRORS) {
				AlertUserOfAPIError(STR_API_NOT_FOUND);
			}
			err = false;
		} else {
			if (zbWrapperInitsCommunicationWithBackend) {
				err = zobjAPI.LMSInitialize("");
			}
			if (err !== true) {
				if (B_SHOW_API_ERRORS) {
					AlertUserOfAPIError(STR_API_INIT_FAILED);
				}
			}
		}
	}
	return err.toString();
}

function LMSFinish(parm) {
	if ((APIOK()) && (!zbFinishDone)) {
		if (typeof(SaveData) !== "undefined"){
			// The SaveData function can be defined in another script of the SCO
			SaveData();
		}
		if (zbWrapperInitsCommunicationWithBackend) {
			zbFinishDone = (zobjAPI.LMSFinish("") !== "false");
		} else {
			// ??
		}
	}
	return zbFinishDone.toString();
}

// Call these catcher functions rather than trying to call the API adapter directly
function LMSSetValue(n,v) {
	return ((APIOK()) ? zobjAPI.LMSSetValue(n, v) : "false");
}
function LMSGetValue(nam) {
	return ((APIOK()) ? zobjAPI.LMSGetValue(nam) : "");
}
function LMSCommit(parm) {
	return ((APIOK()) ? zobjAPI.LMSCommit("") : "false");
}
function LMSGetLastError(parm) {
	return ((APIOK()) ? zobjAPI.LMSGetLastError("") : "-1");
}
function LMSGetErrorString(n) {
	return ((APIOK()) ? zobjAPI.LMSGetErrorString(n) : "JavaScript");
}
function LMSGetDiagnostic(n) {
	return ((APIOK()) ? zobjAPI.LMSGetDiagnostic(n) : "JavaScript");
}


////////////////////////////////
</script>


<script type="text/javascript" language="JavaScript">
// This is the test harness

// Test option flags
let zbAlertOnAPICall = false;
let zbAlertOnCommProtocolErr = false;

// SCORM protocol logic flags and other housekeeping stuff
let strSCOToTestHref = "";
const strDeadPage = "SCO12TestWrapBLNK.htm";
let zbTestInitDone = false;
let zbTestFinishDone = false;
let zbTestInSession = false;
let zbIgnoreParam2IsNotAString = false;

// Parse any parameters passed on command line

const gaURLParams = [];

function URLParams2Array() {
  let nameVal = ""; // Holds array for a single name-value pair.
  let inString = location.search; // Strips query string from URL.
  let i = 0;
  let v = "";

  // If URL contains a query string, grabs it.
  if (inString.charAt(0) == "?") {
	// Removes "?" character from query string.
	inString = inString.substring(1, inString.length);
  }
  if (inString.length > 0) {
	const aKeypairs = inString.split("&");
	// Loops through name-value pairs.
	for (i = 0; i < aKeypairs.length; i++) {
	  // Splits name-value into array (nameVal[0]=name, nameVal[1]=value).
	  nameVal = aKeypairs[i].split("=");
	  v = nameVal[1];
	  while (v.indexOf("+") > -1) {
		//Got to do this the hard way because of IE
		//bug with 'g' in regular expression /+/g
		v = v.substring(0, v.indexOf("+")) + " " + v.substring(v.indexOf("+") + 1);
	  } //while
	  nameVal[1] = unescape(v);
	  nameVal[0] = nameVal[0].toUpperCase();
	  gaURLParams.push(nameVal);
	}
  }
}

URLParams2Array();

function GetURLParam(nam) {
  nam = nam.toUpperCase();
  
  for (let i = 0; i < gaURLParams.length; i++) {
	if (gaURLParams[i][0] === nam) {
	  return gaURLParams[i][1];
	}
  }
  
  return "";
}


/////// Generic cookie functions

let zdateCookieExpirationDate = new Date();
zdateCookieExpirationDate.toGMTString();

// Mac date bug fix
function FixCookieDate (date) {
  let base = new Date(0);
  let skew = base.getTime();
  if (skew > 0) date.setTime (date.getTime() - skew);
}

// Parses document's cookie for a named value
function GetCookie (name) {

  //alert (document.cookie)

  let arg = name + "=";
  let arglen = arg.length;
  let clen = document.cookie.length;
  let i = 0;
  while (i < clen) {
    let j = i + arglen;
    if (document.cookie.substring(i, j) == arg) {
      //return getCookieVal (j);
  		let p3 = document.cookie.indexOf (";", j);
  		if (p3 < 0) p3 = document.cookie.length;
  		return unescape(document.cookie.substring(j, p3));
		}
    i = document.cookie.indexOf(" ", i) + 1;
    if (i == 0) break; 
  }
  return null;
}


function SetCookie (name,value,expires,path,domain,secure) {
// first 2 params are required, others optional
	if (!(expires)) { expires = zdateCookieExpirationDate ;}
  document.cookie = name + "=" + escape (value) +
    ((expires) ? "; expires=" + expires.toGMTString() : "") +
    ((path) ? "; path=" + path : "") +
    ((domain) ? "; domain=" + domain : "") +
    ((secure) ? "; secure" : "");
	//alert('cookie set to expire ' + expires + ' : ' + GetCookie(name))
}

function DeleteCookie (name,path,domain) {
  if (GetCookie(name)) {
    document.cookie = name + "=" +
      ((path) ? "; path=" + path : "") +
      ((domain) ? "; domain=" + domain : "") +
      "; expires=Thu, 01-Jan-70 00:00:01 GMT";
  }
}

function clearCookies(aNames) {
	if (aNames) {
		for (i=0;i<aNames.length;i++){
			DeleteCookie(aNames[i])
		}
	}
}

FixCookieDate (zdateCookieExpirationDate); 
// Correct for Mac date bug - call only once for given Date object!

// Arbitrary expiration date set to 300 days for this mockup. 
zdateCookieExpirationDate.setTime (zdateCookieExpirationDate.getTime() + (300 * 24 * 60 * 60 * 1000)); 

// End of generic cookie functions

////////////// Pseudo persistent store used if there is no back end LMS

zaPersist = new Array();

function SetPersistValue(nam, v, bOverride)
{
	let aReadOnly = new Array("core.total_time","comments_from_lms",  "core.credit", "core.entry", "core.lesson_mode",  "core.student_id", "core.student_name", "core.total_time", "core.launch_data", "student_data.mastery_score", "student_data.max_time_allowed", "student_data.time_limit_action"); 
  let aDMKeywords = new Array("core._children", "core.score._children", "student_data._children", "student_preference._children");

	ResetError();
	if (nam.indexOf("cmi.objectives.") == 0) return SetObjectiveData(nam,v);
	if (nam.indexOf("cmi.interactions.") == 0) return SetInteractionData(nam,v);
	if (nam.indexOf("cmi.core.session_time") == 0) return SetTimeData(nam,v);
	if (nam.indexOf("cmi.comments") == 0) return SetCommentsData(nam,v);
	if ((!(bOverride)) & (nam.indexOf("cmi.") == 0)) {
		for (i=0;i < aReadOnly.length;i++){
			if (nam.indexOf(aReadOnly[i]) == 4) {
				znLastError = 403; // read only
				return "false"
			}
		}
	}
	if ((!(bOverride)) & (nam.indexOf("cmi.") == 0)) {
		for (i=0;i < aDMKeywords.length;i++){
			if (nam.indexOf(aDMKeywords[i]) == 4) {
				znLastError = 402; // element is keyword
				return "false"
			}
		}
		if ((nam.indexOf("_count") != -1)||(nam.indexOf("_version") != -1)){
				znLastError = 402; // element is keyword
				return "false"
		}
	}
	if ((nam.indexOf(".score") != -1) ||(nam.indexOf(".weighting") != -1)) {
		let n = parseFloat(v);
		if (isNaN(n)){
		  znLastError = 201;
			return "false"
		}
	}	// Here could add a test for validity of moredata types for value in v
	return StorePersistValue(nam,v)
}

function StorePersistValue(nam,v) {
	let i = GetPersistValueIndex(nam);
	//alert("i = " +  i)
	if (i < 0){
		i = zaPersist.length
		let a = new Array(nam, v)
		zaPersist[i] = a;
	} else {
		zaPersist[i][1] = v
		//alert("update persist item: " + zaPersist[i][0] + "\nv : " + zaPersist[i][1])
	}
	return "true";
}

function GetCommentFromLMS(){
	//returns a random comment from an array of eight strings.
const a = ["I admire your patience.", "SCORM, SCORM everywhere and nothing to drink!", "Don't forget to look out the window.", "The limits of ignorance are unknowable.", "There is no LMS here. No comment.", "I'm not a real LMS; I just pretend to be one.", "For one brief moment, it suddenly all made sense.", "Life is short. Eat dessert first."];
  return a[Math.round(Math.random() * (a.length-1))]
}

function GetPersistValue(nam, bOverride) {
  if (nam.indexOf("cmi.objectives.") === 0) {
	return GetObjectiveData(nam);
  }
  
  if (nam.indexOf("cmi.interactions.") === 0) {
	return GetInteractionData(nam);
  }

  const writeOnly = ["core.exit"];

  if (!bOverride && nam.indexOf("cmi.") === 0) {
	for (let i = 0; i < writeOnly.length; i++) {
	  if (nam.indexOf(writeOnly[i]) === 4) {
		return "false";
	  }
	}
  }

  const values = {
	"cmi.core._children": "student_id,student_name,credit,lesson_status,lesson_location,entry,score,exit,lesson_mode,launch_data",
	"cmi.comments_from_lms": GetCommentFromLMS(),
	"cmi.core.score._children": "raw,min,max",
	"cmi.core.credit": "true",
	"cmi.core.lesson_mode": "normal",
	"cmi.core.student_name": "Victor Hugo",
	"cmi.core.student_id": (() => {
	  let s = "";

	  for (let i = 0; i < 255; i++) {
		s += Math.round(Math.random() * 9);
	  }

	  return s;
	})(),
	"cmi.core.total_time": "13:27:45.5",
	"cmi.student_data._children": "mastery_score",
	"cmi.student_data.mastery_score": "75"
  };

  const index = GetPersistValueIndex(nam);

  return index >= 0 ? zaPersist[index][1] : values[nam] || "";
}

function GetPersistValueIndex(nam) {
  for (const [i, values] of zaPersist.entries()) {
	if (values[0] === nam) {
	  return i;
	}
  }
  
  return -1;
}


function ClearPersistValues() {
  const s = STR_THIS_APP_TITLE_IN_CAPS + "\n\n";
  if (APIOK()) {
	s += STR_EXPLAIN_CANNOT_RESET_DATA;
  } else {
	NewAttempt();
	zaPersist.fill(null);
	SetPersistValue("cmi.core.lesson_status", "not attempted", true);
	SetPersistValue("cmi.core.entry", "ab-initio", true);
	SetPersistValue("cmi.core.total_time", "0000:00:00.00", true);
	zaPersistObjectives = [];
	zaPersistInteractions = [];
	zDateBeginTime = null;
	znAccumulatedDuration = 0;
	ResetError(); 
	s += STR_CONFIRM_COULD_RESET_DATA;
  }
  
  alert(s);
}


function SetObjectiveData(what, v) {
  const [_, __, iObj, prop, subProp] = what.split(".");
  ResetError();
  
  if (prop === "_count") {
	znLastError = 403; // read only
  } else if (isNaN(iObj) || iObj < 0 || iObj > zaPersistObjectives.length) {
	// invalid index, too low or too high
	znLastError = 101;
  } else if (!["id", "status", "score"].includes(prop)) {
	znLastError = 201;
  } else {
	const index = parseInt(iObj);
	let adata = zaPersistObjectives[index] || new Array(5);

	if (prop === "score" && !["raw", "min", "max"].includes(subProp)) {
	  znLastError = 201;
	} else {
	  if (subProp === "raw") adata[2] = v;
	  if (subProp === "min") adata[3] = v;
	  if (subProp === "max") adata[4] = v;

	  if (prop === "id") {
		adata[0] = v;
	  } else if (prop === "status") {
		adata[1] = v;
	  }

	  zaPersistObjectives[index] = adata;

	  return "true";
	}
  }
  
  return ResetError() ? "true" : "false";
}

function GetObjectiveData(what) {
  const [_, __, iObj, prop, subProp] = what.split(".");
  ResetError();

  switch (prop) {
	case "_children":
	  return "id,status,score";
	case "_count":
	  return `${zaPersistObjectives.length}`;
	default:
	  const index = parseInt(iObj);
	  if (isNaN(index) || index < 0 || index > zaPersistObjectives.length - 1) {
		znLastError = 201; // bad element name
		return "";
	  } else {
		const adata = zaPersistObjectives[index];
		switch (subProp) {
		  case "id":
			return adata[0];
		  case "status":
			return adata[1];
		  case "score":
			switch (subProp) {
			  case "raw":
				return adata[2];
			  case "min":
				return adata[3];
			  case "max":
				return adata[4];
			  case "_children":
				return ["min", "max", "raw"].join(",");
			  default:
				znLastError = 201; // bad element name
				return "";
			}
		  default:
			znLastError = 201; // bad element name
			return "";
		}
	  }
  }
}
function SetTimeData(what,v) {
	// here update total session time.
	// Real soon now TBD
	return ("true")
}

function SetCommentsData(nam, v) {
	if ((v) && (v.length > 4096)) {
		// TBD too long
	}
	let s = GetPersistValue(nam);
	if (s.length > 0){
		s += v;
	} else {
		s = v;
	}
	if (s.length > 4096){
		s="[...]" + s.substr(5,4091)
	}
	return StorePersistValue(nam, s);
}
function SetInteractionData(what, v) {
  let [_, __, iObj, prop] = what.split(".");
  ResetError();

  const index = parseInt(iObj);
  if (prop == "_count") {
	znLastError = 403; // read only
  } else if (isNaN(index) || index < 0 || index > zaPersistInteractions.length) {
	// invalid index, too low or too high
	znLastError = 101;
  } else {
	const dataIndex = zaPersistInteractions.findIndex((data) => data[0] === what);

	if (dataIndex === -1) {
	  let adata = new Array(10);
	  adata[0] = what;
	  zaPersistInteractions.push(adata);
	} else {
	  let adata = zaPersistInteractions[dataIndex];
	}

	switch (prop) {
	  case "id":
		adata[1] = v;
		break;
	  case "objectives":
		adata[2] = v;
		break;
	  case "time":
		adata[3] = v;
		break;
	  case "type":
		adata[4] = v;
		break;
	  case "correct_responses":
		adata[5] = v;
		break;
	  case "weighting":
		adata[6] = v;
		break;
	  case "student_response":
		adata[7] = v;
		break;
	  case "result":
		adata[8] = v;
		break;
	  case "latency":
		adata[9] = v;
		break;
	  default:
		znLastError = 201;
		return false;
	}

	return true;
  }

  ResetError();
  return false;
}


function GetInteractionData(what) {
  ResetError();
  const [, , prop] = what.split(".");

  switch (prop) {
	case "_children":
	  return "id,objectives,time,type,correct_responses,weighting,student_response,result,latency";
	case "_count":
	  return `${zaPersistInteractions.length}`;
	default:
	  znLastError = 404; // write only
	  return "";
  }
}


////////  SCORM Error trapping and handling

let znLastError = 0;
let zstrErrorDiag = "";

function ResetError() {
	znLastError = 0;
	zstrErrorDiag = ""
}

function ErrorStringFromErrorNumber(errNo) {
	let s = ""
	let n = parseInt(errNo); 
	if (isNaN(n)) {
		return (errNo + ' is an invalid error value.')
	}
	switch(n) {
		case 0 : 
			s = "0 No error."; break; 
		case 101 : 
			s = "101 General exception."; break;
		case 201 : 
			s = "201 Invalid argument error."; break;
		case 202 : 
			s = "202 Element cannot have children"; break;
		case 203 : 

			s = "203 Element not an array - cannot have count"; break;
		case 301 : 
			s = "301 Not initialized"; break;
		case 401 : 
			s = "401 Not implemented error"; break;
		case 402 : 
			s = "402 Invalid set value, element is a keyword"; break;
		case 403 : 
			s = "403 Element is read only"; break;
		case 404 : 
			s = "404 Element is write only"; break;
		case 405 : 
			s = "405 Incorrect Data Type"; break;
		default :
			s = n + " Undefined error"; break;
	}
	return s + "";
}


//////// Reset for another run

function NewAttempt(){
	zbTestInitDone = false;
	zbTestFinishDone = false;
	zbTestInSession = false;
	zbIgnoreParam2IsNotAString = false;
	ResetError();
	znCntObjectives = 0;
}

// Logging functions

let zbLoggingOK = (typeof(WriteLog) == "function");
zwndPopupLog = null;

let zstrLog = "";
let znLogMark = 0;

function WriteLog(s,wnd) {
	let wndLog;
	let p = -1
	let re = "";
	if (wnd == null) {
		wndLog = wndLOGWINDOW
	} else {
		wndLog = wnd
	}
	if (typeof(wndLog) == "undefined") {
		return false
	}
	
	while ((zstrLog.length > 32000) && ( p < 0)) {
		p = zstrLog.indexOf('<br>');
		if (p >=0) {
			zstrLog = '<i>&lt;snip&gt; </i> ' + zstrLog.substr(p + 4)
		}
	}
	re = /\n/gi;
	s = s.replace(re, "<br>&gt;"); // Use > char to indicate sub-entries
	if (zstrLog.length > 0) zstrLog += '<br><hr>';
	zstrLog += s;
	s = '<html><head><title>Log</title></head><body bgcolor="#E0E0E0" color="black" onload="window.scrollTo(0,9999999)"><font face="verdana"><small><small>';
	s += zstrLog;
	s += '</small></small></font></body></html>';
	if ((wndLog) && (!wndLog.closed)) {
		wndLog.document.open();
		wndLog.document.write(s);
		wndLog.document.close();
		wndLog.scrollTo(0,90000000);
	}
	wndLog = zwndPopupLog;
	if ((wndLog) && (!wndLog.closed)) {
		wndLog.document.open();
		wndLog.document.write(s);
		wndLog.document.close();
		wndLog.scrollTo(0,90000000);
	}
}

function ClearLog(wnd){
	zstrLog = "";
	znLogMark = 0;
	WriteLog(zstrLog,wnd);
}

function InsertLogMarker(s) {
	if ((s == null) || (s == "")) {
		znLogMark++;
		s = znLogMark.toString()
	}
	WriteLog("\/* " + s + " *\/")
}

function PrintLog() {
	if (window.wndLOGWINDOW.print){
		window.wndLOGWINDOW.print();
	}
}

function PopupLog(){
		let w = 400;
		let h = 600;
		let wndLog = zwndPopupLog;
		if ((!wndLog) || (wndLog.closed)) {
			window.status = "Opening popup log window";
			let loaderurl = MakeLongURL("SCO12TestWrapBLNK.htm");
			let features = "width=" + w + ",height=" + h + ",scrollbars,resizable,menubar,toolbar,dependent";
			wndLog = window.open(loaderurl,"WndPopupLog",features);
		}
		s = '<html><head><title>'+ STR_THIS_APP_TITLE_IN_CAPS + ' LOG</title></head>'
		s += '<body bgcolor="#E0E0E0" color="black" onload="window.scrollTo(0,9999999)"><font face="verdana"><small><small>';
		s += zstrLog;
		s += '</small></small></font></body></html>';
		if ((wndLog) && (!wndLog.closed)) {
			wndLog.document.open();
			wndLog.document.write(s);
			wndLog.document.close();
			wndLog.scrollTo(0,90000000);
		}
		if (wndLog.opener) wndLog.opener = self;
		wndLog.focus();
		if (wndLog.activate) wndLog.activate();
		zwndPopupLog = wndLog
}

function ReportCatch(evnt,p1,p2,err){
	let bErr = ((err != null) && (err.length > 0));
	let s = 'API call detected: ' + evnt;
	if (p1 != null) {
		s += '\nParam1="' + p1 + '"'
	}
	if (p2 != null) {
		s += '\nParam2="' + p2 + '"'
	}
	if (bErr) s+= '\n' + err;
	if (zbLoggingOK) WriteLog(s);
	if ((zbAlertOnAPICall) || ((zbAlertOnCommProtocolErr) && (bErr))){
		alert(STR_THIS_APP_TITLE_IN_CAPS + "\n\n" + s)
	}
}
 
////////  Instantiate the API adapter exposed by this wrapper SCO to its "client" SCO.

let API = new Object();

function catchLMSInitialize(parm) {
  ResetError(); 
  const { initialized, communication } = APIOK();
  
  if (initialized) {
	apiRequest("LMSInitialize", parm, (err) => {
	  if (err == "true") {
		zbTestInitDone = true;
		zbTestInSession = true;
		window.status = "Communication session initialized."
	  }
	});
	
	znLastError = zobjAPI.LMSGetLastError();
	return err;
  }

  if (zbTestFinishDone) {
	znLastError = 101; 
	zstrErrorDiag = "Attempting to reinitialize after LMSFinish.";
	return setError("false");
  } else if (zbTestInitDone || zbTestInSession) {
	zstrErrorDiag = "Extra call to LMSInitialize.";
	return setError("false")
  }

  if (!parm || parm.length > 0) {
	zstrErrorDiag = 'LMSFinish parameter is null should be "".';
	return setError("false");
  } 

  ReportCatch("LMSInitialize", parm, null, zstrErrorDiag);

  if (znLastError == 0) {
	if (communication) {
	  WriteLog('Not forwarding LMSInitialize to the API object since the test wrapper is already initialized as a SCO.')
	}
	zbTestInitDone = true;
	zbTestInSession = true;
	window.status = "Communication session initialized."
  }

  return setError("true");
}

function catchLMSFinish(parm) {
  ResetError(); 
  const { initialized, communication } = APIOK();
  
  if (initialized) {
	apiRequest("LMSFinish", parm, (err) => {
	  if (err == "true") {
		zbTestFinishDone = true;
		zbTestInSession = false;
		window.status = "Communication session terminated."
	  }
	});
	
	znLastError = zobjAPI.LMSGetLastError();
	return err;
  }
}

function apiRequest(methodName, parameter, callback) {
  if (!zbWrapperInitsCommunicationWithBackend) {
	ReportCatch(methodName, parameter, null, zstrErrorDiag);
	const err = zobjAPI[methodName](parameter);
	if (zbLoggingOK) WriteLog(`API end returns: "${err}" to the SCO.`);
	callback(err);
  }
}

function setError(val) {
  if (zbLoggingOK) WriteLog(`API returns "${val}" to the SCO.`);
  return val;

	// We are managing LMSFinish attempt by the SCO

	//alert("lmsfinish reported")

	if ((parm == null) || (parm.length > 0)) {
		zstrErrorDiag  ='LMSFinish parameter is null should be "".';
		znLastError = 201;
		err = "false"
	} else if (zbTestFinishDone) {
		zstrErrorDiag = "Extra call to LMSFinish.";
		znLastError = 101; 
		err = "false"
	} else if (!zbTestInitDone) {
		zstrErrorDiag = "Called LMSFinish before LMSInitialize.";
		znLastError = 301; 
		err = "false"
	}

	ReportCatch("LMSFinish", parm, null, zstrErrorDiag)
	if (znLastError == 0) {
		if (APIOK())
		{
			if (zbLoggingOK) WriteLog('Not forwarding LMSFinish to the API object since the wrapper is itself a SCO and will call LMSFinish when unloaded.');
		}
		zbTestFinishDone = true;
		zbTestInSession = false;
		window.status = "Communication session terminated."
		if (GetPersistValue("cmi.core.exit") == "suspend", true) {
 			SetPersistValue("cmi.core.entry", "resume", true);
		} else {
			SetPersistValue("cmi.core.entry", "", true);
		}
		SetPersistValue("cmi.core.exit", "", true);
		// Need to override error that may have been set by the
		// above, since it is us and not the SCO who did the override.
		ResetError();
	}
	if (zbLoggingOK) WriteLog('API returns "' + err + '" to the SCO.');
	return err
}

function catchLMSSetValue(n,v)
{
	let err = "true";
	let v2 = v; // force this to be a string
	let typv = (typeof v);
	let s = "";

	ResetError();
 
	if (typv != "string") {
		s = 'Invalid parameter type. Parameter 2 type should be "string", it is "%1".' 
		zstrErrorDiag = ExpandString(s, typv)
	}

	ReportCatch("LMSSetValue", n, (v + "").substr(0,4096), zstrErrorDiag)

	if (typv != "string") {
		if (!zbIgnoreParam2IsNotAString) {
			s = zstrErrorDiag + ' (Note that parameters are always converted to string for display between quotes in the log.)\n\n';
			s += 'This error is ignored by the SCORM 1.2 test suite 1.2.3 and by many LMS implementations, but will probably cause interoperability problems in the future.';
			s += '\n\n';
			s += 'Click OK to continue to trap the error, or Cancel to convert the parameter to string and bypass the error if it happens again during this communication session.';
			if (!confirm(s)) {
				zbIgnoreParam2IsNotAString = true;
			}
		}
		if (zbIgnoreParam2IsNotAString) {
			v2 =  v + "";
			typv = (typeof v2);
			zstrErrorDiag = ""
		}
	}

	if (APIOK()) {
		err = zobjAPI.LMSSetValue(n,v2);
		znLastError = zobjAPI.LMSGetLastError();
		if (zbLoggingOK) WriteLog('Back end returns: ' + err);
	}	else if (!zbTestInitDone) {
		zstrErrorDiag = "Called LMSSetValue before LMSInitialize.";
		znLastError = 301; 
		err = "false"
	} else if (!zbTestInSession) {
		zstrErrorDiag = "Called LMSSetValue after LMSFinish."
		znLastError = 101; 
		err = "false"
	} else if (n.length < 1) {
		zstrErrorDiag = "Called LMSsetValue without an element name."
		znLastError = 201; 
		err = "false"
	} else if (typv != "string") {
		//zstrErrorDiag = "Param 2 is incorrect type: Not a string."
		znLastError = 405; 
		err = "false"
	} else {
		err = SetPersistValue(n, v2.substr(0,4096))
	}
	if (zbLoggingOK) WriteLog('API returns "' + err + '" to the SCO.');
	return err
}

function catchLMSGetValue(nam) {
	let r = '';
	ResetError();
	ReportCatch('LMSGetValue', nam);

	if (APIOK()) {
		r = zobjAPI.LMSGetValue(nam);
		znLastError = zobjAPI.LMSGetLastError();

		if (zbLoggingOK) {
			WriteLog(`Back end returns: ${r}`);
		}
	} else if (!zbTestInitDone) {
		zstrErrorDiag = 'Called LMSGetValue before LMSInitialize.';
		znLastError = 301;
		r = 'false';
	} else if (!zbTestInSession) {
		zstrErrorDiag = 'Called LMSGetValue after LMSFinish.';
		znLastError = 101;
		r = 'false';
	} else if (nam.length < 1) {
		zstrErrorDiag = 'Called LMSGetValue without an element name.';
		znLastError = 201;
	} else {
		r = GetPersistValue(nam);
	}

	if (zbLoggingOK) {
		WriteLog(`API returns "${r}" to the SCO.`);
	}

	return r;
}


function catchLMSCommit(parm) {
	let err = 'true';
	ResetError();
	ReportCatch('LMSCommit', parm);

	if (parm == null || parm.length > 0) {
		zstrErrorDiag = 'LMSCommit parameter is null should be "".';
		znLastError = 201;
		err = 'false';
	} else if (zbTestFinishDone) {
		znLastError = 101;
		zstrErrorDiag = 'Attempting to commit after LMSFinish.';
		err = 'false';
	} else if (!zbTestInSession) {
		znLastError = 301;
		zstrErrorDiag = 'Attempting to commit before LMSInitialize.';
		err = 'false';
	}

	ReportCatch('LMSCommit', parm, null, zstrErrorDiag);

	if (APIOK()) {
		err = zobjAPI.LMSCommit(parm);
		znLastError = zobjAPI.LMSGetLastError();
	}

	if (zbLoggingOK) {
		WriteLog(`API returns "${err}" to the SCO.`);
	}

	return err;
}

function catchLMSGetLastError(parm) {
	let err = '';
	ReportCatch('LMSGetLastError', parm);

	if (parm != null) {
		if (zbLoggingOK) {
			WriteLog('GetLastError called with non-null parameter');
		}
		znLastError = 201;
		err = 'false';
	}

	if (APIOK()) {
		err = zobjAPI.LMSGetLastError(parm);
		znLastError = zobjAPI.LMSGetLastError();
	} else {
		err = `${znLastError}`;
	}

	if (zbLoggingOK) {
		WriteLog(`API returns "${err}" to the SCO.`);
	}

	return err;
}

function catchLMSGetErrorString(parm) {
	ReportCatch('LMSGetErrorString', parm);
	let err;

	if (APIOK()) {
		err = zobjAPI.LMSGetErrorString(parm);
	} else {
		err = ErrorStringFromErrorNumber(parm);
	}

	if (zbLoggingOK) {
		WriteLog(`API returns "${err}" to the SCO.`);
	}

	return err;
}

function catchLMSGetDiagnostic(parm) {
	let err = '';
	const nLastError = znLastError;
	const strLastErrorDiag = zstrErrorDiag;
	ResetError();

	let n = 0;
	if (parm && parm.length) {
		n = parseInt(parm);
	}

	ReportCatch('LMSGetDiagnostic', parm);

	if (APIOK()) {
		err = zobjAPI.LMSGetDiagnostic(parm);
		znLastError = zobjAPI.LMSGetLastError();
	} else if (
		strLastErrorDiag.length > 0 &&
		(parm.length === 0 || n === nLastError)
	) {
		err = `${strLastErrorDiag} Note: Different implementations may return different diagnostic information.`;
	} else if (!isNaN(n)) {
		err = catchLMSGetErrorString(n);
	} else {
		znLastError = 201;
		err = `SCO12TestWrapSCO v.${STR_VERSION}`;
	}

	if (zbLoggingOK) {
		WriteLog(`API returns "${err}" to the SCO.`);
	}

	return err;
}

API.LMSInitialize = catchLMSInitialize;
API.LMSFinish = catchLMSFinish;
API.LMSSetValue = catchLMSSetValue;
API.LMSGetValue = catchLMSGetValue;
API.LMSCommit = catchLMSCommit;
API.LMSGetLastError = catchLMSGetLastError;
API.LMSGetErrorString = catchLMSGetErrorString;
API.LMSGetDiagnostic = catchLMSGetDiagnostic;

// This function is called by clickable objects in the CONTROL frame
function thisMainWindowURLPath() {
  let s = window.location.href;
  const p1 = s.indexOf('?');
  
  if (p1 > 1) {
	s = s.substr(0, p1);
  }
  
  const p2 = Math.max(s.lastIndexOf('/'), s.lastIndexOf('\\'));
  
  if (p2 > 0) {
	return s.substr(0, p2 + 1);
  }
  
  return '';
}


function dosFileNameToUrl(s) {
  const re = new RegExp(/\\/g);
  const p = s.indexOf(':\\');
  
  if (p > 0) {
	s = `/${s.substr(0, p)}|${s.slice(p + 1).replace(re, '/')}`;
  } else {
	s = s.replace(re, '/');
  }

  s = s.replace(/\ /g, '%20');
  s = 'FILE://' + s;
  
  return s;
}


function makeLongUrl(url) {
  let bIsDOS = false;
  const scheme = url.substr(0, 7).toUpperCase();

  if (scheme !== 'HTTP://' && scheme !== 'FILE://') {
	const p = url.indexOf('\\');

	if (p >= 0) {
	  url = dosFileNameToUrl(url);
	} else {
	  url = url.replace(/ /g, '%20');
	  url = thisMainWindowURLPath() + url;
	}
  }

  // alert('Massaged url = ' + url);
  return url;
}

////////// Client SCO management

let zMainStageType = 'frame'; // don't change this!
let zWndCurrentStage = null;
let zbOtherWindowPromptShown = false;
let zSCOLoadDelayTimerID = null;
let zUrlOfSCOToLoad = null;

function setStageType(typ) {
  typ = (typ !== 'frame' && typ !== 'popup') ? 'frame' : typ;
  zMainStageType = typ;
}

function loadSCO(urlSCO) {
  // alert('LoadSCO:' + urlSCO);

  if (!urlSCO) {
	urlSCO = zParam_urlSCO;
  }

  if (!urlSCO) {
	return false;
  }

  const url = makeLongUrl(urlSCO);
  let s2 = '';

  if (zMainStageType === 'frame') {
	s2 += STR_IN_STAGE_FRAME;
  } else {
	s2 += STR_IN_POPUP_WINDOW;
  }

  const s = ExpandString(STR_CONFIRM_LOAD_URL, urlSCO, url, s2);

  if (zbConfirmLoadedURL && !confirm(s)) {
	return false;
  }

  // force unloading to capture end state
  const wndStage = zWndCurrentStage;

  if (wndStage !== wndSTAGEFRAME && wndStage && !wndStage.closed) {
	wndStage.location.href = makeLongUrl('SCO12TestWrapBLNK.htm');
  } else {
	wndSTAGEFRAME.location.href = makeLongUrl('SCO12TestWrapBLNK.htm');
  }

  setCookie('URLSCO', url);

  // Need to wait 1/2 second here for unload scripts to finish executing--if any
  zUrlOfSCOToLoad = url;
  
  if (zSCOLoadDelayTimerID) {
	clearInterval(zSCOLoadDelayTimerID);
  }
  
  zSCOLoadDelayTimerID = setInterval(delayedLoadSCO, 500);
  return true;
}

function delayedLoadSCO() {
  if (zSCOLoadDelayTimerID) {
	clearInterval(zSCOLoadDelayTimerID);
  }

  if (zUrlOfSCOToLoad) {
	// now we can load the new one
	newAttempt();

	if (zbLoggingOK) {
	  writeLog('Resetting API communication state for new session.');
	}

	if (zbLoggingOK) {
	  writeLog(`Loading [${zUrlOfSCOToLoad}]`);
	}

	if (!stageOpen()) {
	  alert('There was a problem opening a stage window.');
	}

	zWndCurrentStage.location.href = zUrlOfSCOToLoad;

	if (zMainStageType !== 'frame') {
	  startStageFocusTimer();
	}

	return true;
  } 
  
  return false;
}

function unloadSCO() {
  killStageFocusTimer();
  stageClose();
  wndSTAGEFRAME.location.href = makeLongUrl('SCO12TestWrapBLNK.htm');
}


function stageClose() {
	if (zWndCurrentStage !== wndSTAGEFRAME && zWndCurrentStage && !zWndCurrentStage.closed) {
	  zWndCurrentStage.close();
	}
  }
  
  function stageOpen() {
	let w = 800;
	let h = 600;
	let wndStage = wndSTAGEFRAME;
  
	if (zMainStageType !== 'frame') {
	  if (zWndCurrentStage && zWndCurrentStage !== wndSTAGEFRAME && !zWndCurrentStage.closed) {
		wndStage = zWndCurrentStage;
	  } else {
		const url = MakeLongURL('SCO12TestWrapBLNK.htm');
		const features = `width=${w},height=${h},scrollbars,resizable,status,dependent`;
  
		window.status = 'Opening stage window';
		wndStage = window.open(url, 'WndCurrentStage', features);
  
		if (!wndStage.opener) {
		  wndStage.opener = self;
		}
	  }
  
	  const s = '<html><head><style type="text/css">body {background-color: silver; color: blue;font-size: small;font-family: Verdana, Arial, Helvetica,Sans-Serif}</style></head><body><h3>The SCO was launched in another window.</h3></body></html>';
  
	  wndSTAGEFRAME.location.href = MakeLongURL('SCO12TestWrapBLNK.htm');
	  wndSTAGEFRAME.document.open();
	  wndSTAGEFRAME.document.write(s);
	  wndSTAGEFRAME.document.close();     
	  zbOtherWindowPromptShown = true;
	  wndStage.focus();
	}
  
	zWndCurrentStage = wndStage;
	return true;
  }
  

function handleActivate() {
	// Check whether a stage window was open, and if just got closed
	// remove the other window warning
	if (zMainStageType !== 'frame') {
	  if (zWndCurrentStage && !zWndCurrentStage.closed) {
		return null;
	  }
	}
	
	if (zbOtherWindowPromptShown) {
	  zbOtherWindowPromptShown = false;
	  wndSTAGEFRAME.location.href = MakeLongURL('SCO12TestWrapBLNK.htm');
	}
  }
  
  let zPopupStageTimerID = null;
  
  function popupStageFocus() {
	if (zWndCurrentStage !== wndSTAGEFRAME && zWndCurrentStage && !zWndCurrentStage.closed) {
	  zWndCurrentStage.focus();
	}
  }
  
  function popupStageFocusTimer() {
	// called by timer while a popup stage is open
	if (zWndCurrentStage !== wndSTAGEFRAME) {
	  if (zWndCurrentStage && !zWndCurrentStage.closed) {
		if (!zbOtherWindowPromptShown) {
		  const s = '<html><head><style type="text/css">body {background-color: silver; color: blue;font-size: small;font-family: Verdana, Arial, Helvetica,Sans-Serif}</style></head>';
		  const s2 = '<body><h3>The SCO was launched in another window.</h3>Click <a href="javaScript:window.parent.PopupStageFocus()">here</a> to reactivate it.</body></html>';
		  
		  wndSTAGEFRAME.location.href = MakeLongURL('SCO12TestWrapBLNK.htm');
		  wndSTAGEFRAME.document.open();
		  wndSTAGEFRAME.document.write(s + s2);
		  wndSTAGEFRAME.document.close();     
		  zbOtherWindowPromptShown = true;
		}
	  } else {
		killStageFocusTimer();
		wndSTAGEFRAME.location.href = MakeLongURL('SCO12TestWrapBLNK.htm');
	  }
	}
  }
  
  function startStageFocusTimer() {
	clearInterval(zPopupStageTimerID);
	
	zbOtherWindowPromptShown = false;
	zPopupStageTimerID = setInterval(popupStageFocusTimer, 500);
  }
  
  function killStageFocusTimer() {
	clearInterval(zPopupStageTimerID);
	zbOtherWindowPromptShown = false; 
  }
  
  function errorFoundAPIInSiblingFrame() {
	// called if a dummy API adapter was called first
	alert('Unrecoverable SCO Error\n\nIncorrect API search order. The launched SCO searched for API adapter object in a sibling frame before looking for it in the proper places.');
  }
  
  let zRepairFocusTimerID = null;
  
  function repairFocus() {
	clearInterval(zRepairFocusTimerID);
	zRepairFocusTimerID = setInterval(repairFocusTimer, 500);
  }
  
  function repairFocusTimer() {
	clearInterval(zRepairFocusTimerID);
	wndSTAGEFRAME.focus();
  }
  

////////// Initialization and cleanup

function wrapperInitialize() {
	LMSInitialize();
	const urlSCO = GetURLParam('SCO');
	
	if (zbLoggingOK) {
	  WriteLog(StrAboutThisAsHTML());
  
	  const backEndAPI = APIOK() ? 'Back end' : 'No back end';
	  WriteLog(`${backEndAPI} API object detected. API calls from the SCO to the API object in the wrapper will be ${APIOK() ? 'forwarded to the API object in the back end' : 'handled locally by the wrapper'}.`);
  
	  if (urlSCO) {
		zbConfirmLoadedURL = false;
		window.status = `Launch SCO parameter = ${urlSCO}`;
  
		if (LoadSCO(urlSCO)) {
		  if (!zParam_urlSCO) {
			wndTOOLBAR.SetShownLocation(unescape(urlSCO));
		  }
		}
  
		WriteLog(`Wrapper launched with parameter SCO=${urlSCO}`);
		return true;
	  }
	}
  }
  
  function wrapperFinish() {
	//wndSTAGEFRAME.location.href="SCO12TestWrapBLNK.htm";
	LMSFinish();
  }
  

//alert("SCO wrapper script appears to have loaded correctly.")
function loadStage(){
zParam_urlSCO = GetURLParam("SCO");
setStageType(GetURLParam("STAGE").toLowerCase());
let s = GetURLParam("RERUNOK").toLowerCase();
if ((s == "ok") || (s == "yes") || (s == "true")) {
	zbRerunOK = true;
	zbWrapperInitsCommunicationWithBackend = true;
}

s = "";
s += '<title>Click2learn Demo SCORM 1.2 Test Wrapper</title>';
s += '</head>';
s += '<frameset cols="200,*" onload="WrapperInitialize()" onunload="wrapperFinish()" onbeforeunload="wrapperFinish()" onactivate ="HandleActivate()">'
s += '	<frameset rows="115,*">'
s += '		<frame src="SCO12TestWrapCPL.htm" name="wndCONTROLPANEL" scrolling="no" />'
s += '		<frame src="SCO12TestWrapBLNK.htm" name="wndLOGWINDOW" />'
s += '	</frameset>'
if ((zParam_urlSCO == null) || (zParam_urlSCO == "")) {
	s += '	<frameset rows=25,100%">'
	s += '		<frame src="SCO12TestWrapSCOLOC.htm" name = "wndTOOLBAR" scrolling="no"/>'
	s += '		<frame src="SCO12TestWrapReadMe.htm" name="wndSTAGEFRAME" />'
	s += '  </frameset>'
} else {
	s += '		<frame src="SCO12TestWrapReadMe.htm" name="wndSTAGEFRAME" />'
}
s += '</frameset>'
document.write(s)
}
</script>
<body onload="loadStage();"></body>
</html>